---
id: create-dedicated-sql-builder-for
level: task
title: "Create dedicated SQL builder for WRITE clauses (CREATE/SET/DELETE/REMOVE)"
short_code: "GQLITE-T-0064"
created_at: 2025-12-27T17:07:04.922746+00:00
updated_at: 2025-12-27T17:07:04.922746+00:00
parent: GQLITE-I-0025
blocked_by: []
archived: true

tags:
  - "#task"
  - "#phase/todo"


exit_criteria_met: false
strategy_id: NULL
initiative_id: GQLITE-I-0025
---

# Create dedicated SQL builder for WRITE clauses (CREATE/SET/DELETE/REMOVE)

## Priority: LOW (Optional Enhancement)

The unified SQL builder initiative is complete for READ queries. This task tracks optional future work to apply similar patterns to WRITE queries.

## Parent Initiative

[[GQLITE-I-0025]]

## Objective

Create a dedicated builder pattern for SQL INSERT/UPDATE/DELETE statements generated by Cypher WRITE clauses, replacing direct `append_sql()` usage with structured clause assembly.

## Current State

WRITE clauses currently use `append_sql()` directly (45 total calls):
- `transform_set.c` - 18 calls
- `transform_create.c` - 14 calls
- `transform_remove.c` - 7 calls
- `transform_delete.c` - 6 calls

These generate INSERT/UPDATE/DELETE SQL which has different patterns than SELECT queries.

## Acceptance Criteria

## Acceptance Criteria

- [x] Create `write_builder` struct for INSERT/UPDATE/DELETE
- [x] Implement write_builder API functions
- [x] Add unit tests for write_builder (12 tests added)
- [x] All existing tests pass (733 C + 160 Python)
- [x] No regressions in WRITE query functionality

## Migration Assessment

After implementing the write_builder API and analyzing the WRITE clause code, the migration of individual transform files was determined to be **lower value** because:
- Current `append_sql()` pattern works correctly and is appropriate for incremental statement building
- WRITE clauses already partially integrate with unified_builder (reading FROM/JOIN/WHERE state)
- Migration would be invasive with marginal structural benefit
- The write_builder API is available for future use and external callers

## Implementation Notes

### Technical Approach

WRITE queries generate different SQL patterns than READ queries:
- CREATE → INSERT INTO
- SET → UPDATE with subqueries
- DELETE → DELETE with subqueries
- REMOVE → UPDATE (set to NULL)

A dedicated `write_builder` could provide:
- `write_insert(table, columns, values)`
- `write_update(table, set_clause, where)`
- `write_delete(table, where)`

### Why This Is Optional

The current `append_sql()` approach:
- Works correctly (all tests pass)
- Is straightforward for WRITE operations
- Doesn't have the clause-ordering complexity that READ queries have

The main benefit would be consistency with the READ query pattern.

## Status Updates

**2025-12-27**: Completed write_builder API implementation:
- Added `write_builder` struct to sql_builder.h
- Implemented: `write_builder_create/free/reset`, `write_insert_values`, `write_insert_select`, `write_delete`, `write_delete_where_in`, `write_raw`, `write_builder_to_string`
- Added 12 unit tests covering all functions
- Test count increased from 721 to 733 C tests
- Determined that migrating existing transform files provides marginal benefit since `append_sql()` pattern is appropriate for incremental WRITE statement building